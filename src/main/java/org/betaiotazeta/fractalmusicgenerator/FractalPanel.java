package org.betaiotazeta.fractalmusicgenerator;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadLocalRandom;
import javax.sound.midi.InvalidMidiDataException;
import javax.sound.midi.MidiUnavailableException;
import javax.sound.sampled.LineUnavailableException;

public class FractalPanel extends javax.swing.JPanel {

    public FractalPanel() {
        // used only for Gui Builder
    }

    public FractalPanel(FmgApp fmgApp) {
        this.fmgApp = fmgApp;
        initComponents();
        
        this.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent evt) {
                fmgApp.getFractalPanel().redrawImages();
                fmgApp.getColorPanel().drawPreviewColors();
            }
        });
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                FractalPanel.this.mouseDragged(evt);
            }
        });
        addMouseWheelListener(new java.awt.event.MouseWheelListener() {
            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
                FractalPanel.this.mouseWheelMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                FractalPanel.this.mouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                FractalPanel.this.mousePressed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void mouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mouseClicked
        int px = evt.getX();
        int py = evt.getY();
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();
        double cx = Utilities.scale(px, 0, panelWidth, minA, maxA);
        double cy = Utilities.scale(py, 0, panelHeight, maxB, minB);
        String str = "Mouse clicked for x: " + cx + ", y: " + cy + nl;
        fmgApp.getTab1TextArea().append(str);
        playPixel(cx, cy);
    }//GEN-LAST:event_mouseClicked

    private void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {//GEN-FIRST:event_mouseWheelMoved
        int wheelRotationDirection = evt.getWheelRotation();
        // mac will report mouse movements in number of "clicks", >0 or <0
        // -1 or +1 is typical for linux and windows
        if (wheelRotationDirection > 0) {
            wheelRotationDirection = 1;
        } else {
            wheelRotationDirection = -1;
        }
        double wheelScalingFactor;
        if (wheelRotationDirection == -1) {
            wheelScalingFactor = 1 - wheelScalingSensitivity;
        } else {
            wheelScalingFactor = 1 + wheelScalingSensitivity;
        }
        if (zoom * wheelScalingFactor > 1) return; // limiting zooming out
        int px = evt.getX();
        int py = evt.getY();
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();
        double cx = Utilities.scale(px, 0, panelWidth, minA, maxA);
        double cy = Utilities.scale(py, 0, panelHeight, maxB, minB);
        double deltaA = cx - minA;
        double deltaB = cy - minB;

        // translating from click point to lowerLeft corner
        minA = minA + deltaA;
        minB = minB + deltaB;
        // maxA = maxA + deltaA; // minA + (zoom * panelWidth);
        // maxB = maxB + deltaB; // minB + (zoom * panelHeight);

        // zooming
        zoom = zoom * wheelScalingFactor;
        maxA = minA + (zoom * panelWidth);
        maxB = minB + (zoom * panelHeight);

        // translating from lowerLeft corner to click point
        minA = minA - (deltaA * wheelScalingFactor);
        minB = minB - (deltaB * wheelScalingFactor);
        maxA = maxA - (deltaA * wheelScalingFactor);
        maxB = maxB - (deltaB * wheelScalingFactor);
        
        adjustImageIterations();
    }//GEN-LAST:event_mouseWheelMoved

    private void mouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mouseDragged
        int px = evt.getX();
        int py = evt.getY();
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();
        double cx = Utilities.scale(px, 0, panelWidth, minA, maxA);
        double cy = Utilities.scale(py, 0, panelHeight, maxB, minB);
        double cxMouseDragOld = Utilities.scale(pxMouseDragOld, 0, panelWidth, minA, maxA);
        double cyMouseDragOld = Utilities.scale(pyMouseDragOld, 0, panelHeight, maxB, minB);
        double deltaA = cx - cxMouseDragOld;
        double deltaB = cy - cyMouseDragOld;

        // translating
        minA = minA - deltaA;
        minB = minB - deltaB;
        maxA = maxA - deltaA;
        maxB = maxB - deltaB;

        pxMouseDragOld = px;
        pyMouseDragOld = py;

        redrawImages();
    }//GEN-LAST:event_mouseDragged

    private void mousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mousePressed
        int px = evt.getX();
        int py = evt.getY();
        pxMouseDragOld = px;
        pyMouseDragOld = py;
    }//GEN-LAST:event_mousePressed

    public void playOutline() {
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();
        double minAold = minA;
        double maxAold = maxA;
        double minBold = minB;
        double maxBold = maxB;
        
        Runnable outline = new Runnable() {
            @Override
            public void run() {
                String message = "Starting outline detection, please wait..." + nl;
                fmgApp.getTab1TextArea().append(message);
                
                final BufferedImage imageFractalCopy = new BufferedImage(
                        imageFractal.getWidth(), imageFractal.getHeight(), BufferedImage.TYPE_INT_RGB);
                Graphics2D g2d = imageFractalCopy.createGraphics();
                g2d.drawImage(imageFractal, 0, 0, null);
                g2d.dispose();
                
                Callable<Area> area = new Callable<>() {
                    @Override
                    public Area call() throws Exception {
                        Area fractalArea = retreiveOutline(Color.BLACK, imageFractalCopy);
                        return fractalArea;
                    }
                };
                FutureTask<Area> retreivedArea = new FutureTask<>(area);
                Thread areaRetrieverThread = new Thread(retreivedArea);
                areaRetrieverThread.start();
                
                while (!retreivedArea.isDone()) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException ex) {
                        // ExecService thread interrupted while sleeping, waiting for FutureTask to be completed
                        // retreiveOutline method won't check for interrupt flag
                        // areaRetrieverThread will terminate eventually
                        retreivedArea.cancel(true); // same as areaRetrieverThread.interrupt(); does nothing
                        return;
                    }
                }
                
                Area fractalArea;
                try {
                    fractalArea = (Area) retreivedArea.get();
                } catch (InterruptedException | ExecutionException ex) {
                    return;
                }                               
                message = "Outline detection finished, retreiving values to play..." + nl;
                fmgApp.getTab1TextArea().append(message);
                
                ArrayList<short[]> outlinePixelArrayList = retreiveOutlineValuesFromArea(fractalArea);
                convertOutlinePixelToComplex(outlinePixelArrayList,
                        panelWidth, panelHeight, minAold, maxAold, minBold, maxBold);
                int outlineSize = outlinePixelArrayList.size();
                message = "Retreived " + outlineSize + " pixels, now playing..." + nl;
                fmgApp.getTab1TextArea().append(message);
                imagePath = new BufferedImage(panelWidth, panelHeight, BufferedImage.TYPE_INT_ARGB);
                
                // draw and play
                int playedPixelsCount = 0;
                int loopsCount = 0;
                do {
                    double cx; double cy;
                    // outlinePixelArrayList.size() == outlineComplexArrayList.size()
                    for (int i = loopsCount; i < outlinePixelArrayList.size(); i++) {
                        imagePathIndex = i;
                        if (fmgApp.getLockOutlineToggleButton().isSelected() == true) {
                            cx = outlineComplexArrayList.get(i)[0];
                            cy = outlineComplexArrayList.get(i)[1];                            
                        } else {
                            int px = outlinePixelArrayList.get(i)[0];
                            int py = outlinePixelArrayList.get(i)[1];
                            // if panel is resized, width / height will change
                            // consider using a class variable pair
                            int panelWidthResized = fmgApp.getFractalPanel().getWidth();
                            int panelHeightResized = fmgApp.getFractalPanel().getHeight();
                            // if panel size becomes 0, fake values are used,
                            // so we still have something to play on
                            if ((panelWidthResized == 0) || (panelHeightResized == 0)) {
                                panelWidthResized = 100;
                                panelHeightResized = 100;
                                maxA = minA + (zoom * panelWidthResized);
                                minB = maxB - (zoom * panelHeightResized);
                            }                           
                            cx = Utilities.scale(px, 0, panelWidthResized, minA, maxA);
                            cy = Utilities.scale(py, 0, panelHeightResized, maxB, minB);
                        }

                        // draw
                        int skipPixels = fmgApp.getOutlineSkipSlider().getValue();
                        if (skipPixels > 0) {
                            i = i + skipPixels;
                            drawPath(true, -1, -1); // ignored if unlocked
                            drawPath(false, cx, cy); //redrawing last pixel if locked
                        } else {
                            drawPath(false, cx, cy);
                        }

                        // play
                        playPixel(cx, cy);
                        playedPixelsCount++;

                        // slowing down play
                        try {
                            int baseSleepTime = fmgApp.getOutlineSpeedSlider().getValue();
                            int randomSleepTime = fmgApp.getOutlineSpeedRandomnessSlider().getValue();
                            ThreadLocalRandom random = ThreadLocalRandom.current();
                            int sleepTotal = baseSleepTime + random.nextInt(randomSleepTime);
                            Thread.sleep(sleepTotal); // 500
                        } catch (InterruptedException ex) {
                            return;
                        }
                    }
                    loopsCount++;
                    if (fmgApp.getOutlineSkipSlider().getValue() == 0) {
                        clearImagePath();
                    } 
                    message = "All outline pixels processed." + nl;
                    fmgApp.getTab1TextArea().append(message);
                } while (fmgApp.getLoopingCheckBox().isSelected() &&
                        outlinePixelArrayList.size() > loopsCount);

                message = "Played " + playedPixelsCount + " pixels. Finished!" + nl;
                fmgApp.getTab1TextArea().append(message);
            }
        };
        fmgApp.getAudioExecutorService().execute(outline);
    }

    private Area retreiveOutline(Color target, BufferedImage bi) {
        // https://stackoverflow.com/questions/10834109/java-create-a-shape-from-border-around-image
        int width = bi.getWidth();
        int height = bi.getHeight();
        GeneralPath gp = new GeneralPath();
        boolean cont = false;
        int targetRGB = target.getRGB();
        
        for (int xx = 0; xx < width; xx++) {
            for (int yy = 0; yy < height; yy++) {                
//                if (Thread.currentThread().isInterrupted()) { // not used, won't work
//                    return null;
//                }
                if (bi.getRGB(xx, yy) == targetRGB) {
                    if (cont) {
                        gp.lineTo(xx, yy);
                        gp.lineTo(xx, yy + 1);
                        gp.lineTo(xx + 1, yy + 1);
                        gp.lineTo(xx + 1, yy);
                        gp.lineTo(xx, yy);
                    } else {
                        gp.moveTo(xx, yy);
                    }
                    cont = true;
                } else {
                    cont = false;
                }
            }
            cont = false;
        }
        // gp.closePath(); // do not close, maybe there was not an initial MOVE_TO

        // construct the Area from the GP and return it
        return new Area(gp);
    }

    private Area retreiveOutlineAlternative(Color targetColor, BufferedImage bufferedImage) {
        // unused, probably slower
        Area area = new Area();
        int targetColorRGB = targetColor.getRGB();
        int imageWidth = bufferedImage.getWidth();
        int imageHeight = bufferedImage.getHeight();
        for (int x = 0; x < imageWidth; x++) {
            for (int y = 0; y < imageHeight; y++) {
                if (bufferedImage.getRGB(x, y) == targetColorRGB) {
                    Rectangle rectangle = new Rectangle(x, y, 1, 1);
                    area.add(new Area(rectangle));
                }
            }
        }
        return area;
    }

    private ArrayList<short[]> retreiveOutlineValuesFromArea(Area area) {
        short xOld = -1;
        short yOld = -1;
        // it is unknown how many pixels we will have to play 
        // we can overprovision an array (not memory efficient)
        // short[] outlineArray = new short[panelWidth * panelHeight * 2];
        // or use ArrayList (but we create a lot of objects)
        ArrayList<short[]> outlinePixelArrayList = new ArrayList<>();  

        PathIterator pathIterator = area.getPathIterator(null);
        // A float array of length 6 must be passed
        // only SEG_MOVETO(0), SEG_LINETO(1), SEG_CLOSE(4) types seem to be effectively used
        // A point is stored as a pair of float x,y coordinates as array[0] and array[1]
        // SEG_CLOSE(4) follows an already reached point
        float[] segmentArray = new float[6];

        while (!pathIterator.isDone()) {
            int segmentType = pathIterator.currentSegment(segmentArray);

            // apparently there is no loss with casting
            short x = (short) segmentArray[0];
            short y = (short) segmentArray[1];

            // initializing first value
            if (xOld == -1) {
                xOld = x;
                yOld = y;
            }

            if (segmentType == 1) {
                if (x > xOld) {
                    for (short ad = xOld; ad < x; ad++) {
                        short[] values = {ad, y};
                        outlinePixelArrayList.add(values);
                    }
                }
                if (x < xOld) {
                    for (short ad = xOld; ad > x; ad--) {
                        short[] values = {ad, y};
                        outlinePixelArrayList.add(values);
                    }
                }
                if (y > yOld) {
                    for (short ad = yOld; ad < y; ad++) {
                        short[] values = {x, ad};
                        outlinePixelArrayList.add(values);
                    }

                }
                if (y < yOld) {
                    for (short ad = yOld; ad > y; ad--) {
                        short[] values = {x, ad};
                        outlinePixelArrayList.add(values);
                    }
                }
            }

            pathIterator.next();
            // old values will be updated for all segmentTypes! (0, 1, 4)
            xOld = x;
            yOld = y;
        }
        return outlinePixelArrayList;
    }
    
    private void convertOutlinePixelToComplex(ArrayList<short[]> outlinePixelArrayList,
            int panelWidth, int panelHeight, double minAold, double maxAold, double minBold, double maxBold) {
        outlineComplexArrayList = new ArrayList<double[]>();
        for (int i = 0; i < outlinePixelArrayList.size(); i++) {
            int px = outlinePixelArrayList.get(i)[0];
            int py = outlinePixelArrayList.get(i)[1];
            double cx = Utilities.scale(px, 0, panelWidth, minAold, maxAold);
            double cy = Utilities.scale(py, 0, panelHeight, maxBold, minBold);
            double[] values = {cx, cy};
            outlineComplexArrayList.add(values);
        }
    }
    
    private void playPixel(double cx, double cy) {
        Runnable pixel = new Runnable() {
            @Override
            public void run() {

                OrbitCalculator orbitCalculator = new OrbitCalculator(fmgApp.getMaxAudioIterationsSlider().getValue());

                int fractalIndex = fmgApp.getConfigurator().getFractalIndex();
                switch (fractalIndex) {
                    case 0:
                        orbitCalculator.calculateMandelbrotOrbits(cx, cy);
                        break;
                    case 1:
                        orbitCalculator.calculateBurningShipOrbits(cx, cy);
                        break;
                    case 2:
                        orbitCalculator.calculateTricornOrbits(cx, cy);
                        break;
                    case 3:
                        orbitCalculator.calculateRectangleOrbits(cx, cy);
                        break;
                    case 4:
                        orbitCalculator.calculateKlingonOrbits(cx, cy);
                        break;
                    case 5:
                        orbitCalculator.calculateCrownOrbits(cx, cy);
                        break;
                    case 6:
                        orbitCalculator.calculateFrogOrbits(cx, cy);
                        break;
                    case 7:
                        orbitCalculator.calculateMandelshipOrbits(cx, cy);
                        break;
                    case 8:
                        orbitCalculator.calculateFrankensteinOrbits(cx, cy);
                        break;
                    case 9:
                        orbitCalculator.calculateLogisticOrbits(cx, cy);
                        break;
                }

                if (Thread.currentThread().isInterrupted()) {
                    return;
                }

                Runnable lines = new Runnable() {
                    @Override
                    public void run() {
                        drawOrbits(orbitCalculator);
                    }
                };

                Runnable melody = new Runnable() {
                    @Override
                    public void run() {
                        try {
                            fmgApp.getSoundGenerator().playMelody(orbitCalculator);
                        } catch (InterruptedException ex) {
                            // do nothing
                        } catch (MidiUnavailableException ex) {
                            String message = "MidiUnavailableException!" + nl;
                            fmgApp.getTab1TextArea().append(message);
                        } catch (InvalidMidiDataException ex) {
                            String message = "InvalidMidiDataException!" + nl;
                            fmgApp.getTab1TextArea().append(message);
                        }
                    }
                };

                Runnable drums = new Runnable() {
                    @Override
                    public void run() {
                        try {
                            fmgApp.getSoundGenerator().playDrums(orbitCalculator);
                        } catch (InterruptedException ex) {
                            // do nothing
                        } catch (MidiUnavailableException ex) {
                            String message = "MidiUnavailableException!" + nl;
                            fmgApp.getTab1TextArea().append(message);
                        } catch (InvalidMidiDataException ex) {
                            String message = "InvalidMidiDataException!" + nl;
                            fmgApp.getTab1TextArea().append(message);
                        }
                    }
                };

                Runnable wave = new Runnable() {
                    @Override
                    public void run() {
                        try {
                            fmgApp.getSoundGenerator().playWave(orbitCalculator);
                        } catch (InterruptedException ex) {
                            // do nothing
                        } catch (LineUnavailableException ex) {
                            String message = "LineUnavailableException!" + nl;
                            fmgApp.getTab1TextArea().append(message);
                        }
                    }
                };

                try {
                    if (fmgApp.getDrawOrbitsCheckBox().isSelected()) {
                        fmgApp.getAudioExecutorService().execute(lines);
                    }

                    if (fmgApp.getMelodyToggleButton().isSelected()) {
                        fmgApp.getAudioExecutorService().execute(melody);
                    }

                    if (fmgApp.getDrumsToggleButton().isSelected()) {
                        fmgApp.getAudioExecutorService().execute(drums);
                    }

                    if (fmgApp.getWaveToggleButton().isSelected()) {
                        fmgApp.getAudioExecutorService().execute(wave);
                    }
                } catch (RejectedExecutionException ex) {
                    // do nothing
                }
            }
        };
        try {
            fmgApp.getAudioExecutorService().execute(pixel);
        } catch (RejectedExecutionException ex) {
            // do nothing
        }
    }

    private void drawOrbits(OrbitCalculator orbitCalculator) {
        // orbitsArray in orbitCalculator contains all orbit points including c
        // first line is drawn as a dot
        orbitCalculatorOld = orbitCalculator;
        ComplexNumber[] orbitsArray = orbitCalculator.getOrbitsArray(); 
        if (orbitsArray[0] == null) {
            return;
        }
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();
        if ((panelWidth == 0) || (panelHeight == 0)) return;
        double zx = orbitsArray[0].getRealValue();
        double zy = orbitsArray[0].getImaginaryValue();
        int px = (int) Utilities.scale(zx, minA, maxA, 0, panelWidth);
        int py = (int) Utilities.scale(zy, minB, maxB, panelHeight, 0);
        int px1;
        int py1;

        imageOrbits = new BufferedImage(panelWidth, panelHeight,
                BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = imageOrbits.createGraphics();
        g2d.setColor(Color.RED);

        for (ComplexNumber cn : orbitsArray) {
            if (cn == null) {
                break;
            }
            zx = cn.getRealValue();
            zy = cn.getImaginaryValue();
            px1 = (int) Utilities.scale(zx, minA, maxA, 0, panelWidth);
            py1 = (int) Utilities.scale(zy, minB, maxB, panelHeight, 0);

            g2d.drawLine(px, py, px1, py1);
            px = px1;
            py = py1;
        }
        g2d.dispose();
        repaint();
    }
    
    private void drawPath(boolean reset, double cx, double cy) {
        if (imagePath == null) {
            return;
        }
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();

        if (reset == true && (fmgApp.getLockOutlineToggleButton().isSelected() == true)) {
            if ((panelWidth == 0) || (panelHeight == 0)) return;
            imagePath = new BufferedImage(panelWidth, panelHeight,
                    BufferedImage.TYPE_INT_ARGB);
            Graphics2D g2d = imagePath.createGraphics();
            g2d.setPaint(Color.WHITE);
            for (int i = 0; i < imagePathIndex; i++) {
                cx = outlineComplexArrayList.get(i)[0];
                cy = outlineComplexArrayList.get(i)[1];
                int px = (int) Utilities.scale(cx, minA, maxA, 0, panelWidth);
                int py = (int) Utilities.scale(cy, minB, maxB, panelHeight, 0);
                g2d.fillOval(px - 1, py - 1, 2, 2);
            }
            g2d.dispose();
        } else {
            if (reset == false) {
                if ((panelWidth == 0) || (panelHeight == 0)) {
                    panelWidth = 100;
                    panelHeight = 100;
                    maxA = minA + (zoom * panelWidth);
                    minB = maxB - (zoom * panelHeight);
                }
                Graphics2D g2d = imagePath.createGraphics();
                g2d.setPaint(Color.WHITE);
                int px = (int) Utilities.scale(cx, minA, maxA, 0, panelWidth);
                int py = (int) Utilities.scale(cy, minB, maxB, panelHeight, 0);
                g2d.fillOval(px - 1, py - 1, 2, 2);
                g2d.dispose();
            }
        }
        repaint();
    }
    
    public void drawCoordinates() {
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();
        if ((panelWidth == 0) || (panelHeight == 0)) return;
        imageCoordinates = new BufferedImage(panelWidth, panelHeight,
                BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = imageCoordinates.createGraphics();
        g2d.setColor(Color.WHITE);

        // draw values at the border
        int fA = g2d.getFontMetrics().getAscent();
        int fD = g2d.getFontMetrics().getDescent();
        int bonus = fD;
        String minAs = String.format("x : %+1.2f", minA);
        String minBs = String.format("y : %+1.2f", minB);
        String maxAs = String.format("x : %+1.2f", maxA);
        String maxBs = String.format("y : %+1.2f", maxB);
        String text;
        text = minAs + ", " + maxBs;
        g2d.drawString(text, 0 + bonus, fA);
        text = maxAs + ", " + maxBs;
        g2d.drawString(text, panelWidth - g2d.getFontMetrics().stringWidth(text) - bonus, fA);
        text = minAs + ", " + minBs;
        g2d.drawString(text, 0 + bonus, panelHeight - fD);
        text = maxAs + ", " + minBs;
        g2d.drawString(text, panelWidth - g2d.getFontMetrics().stringWidth(text) - bonus, panelHeight - fD);

        // draw axis at (0,0)
        int px0 = (int) Utilities.scale(0, minA, maxA, 0, panelWidth);
        int py0 = (int) Utilities.scale(0, minB, maxB, panelHeight, 0);
        if (minA < 0 && maxA > 0) {
            g2d.drawLine(px0, 0, px0, panelHeight);
        }
        if (minB < 0 && maxB > 0) {
            g2d.drawLine(0, py0, panelWidth, py0);
        }

        // draw ticks
        int tL; // tick length
        String tickNumber;
        int minAi = (int) minA - 1;
        int minBi = (int) minB - 1;
        int maxAi = (int) maxA + 1;
        int maxBi = (int) maxB + 1;
        // x values
        int loops = (int) (maxAi - minAi) * 10;
        double value = minAi;
        int tickCount = minAi;
        for (int i = 0; i < loops; i++) {
            int pxt = (int) Utilities.scale(value, minA, maxA, 0, panelWidth);
            if (i % 10 == 0) {
                tL = 5;
                if (tickCount != 0) {
                    tickNumber = tickCount + "";
                    int sL = g2d.getFontMetrics().stringWidth(tickNumber) / 2;
                    g2d.drawString(tickNumber, pxt - sL, py0 + tL + fA);
                }
                tickCount++;
            } else {
                tL = 2;
            }
            g2d.drawLine(pxt, py0 - tL, pxt, py0 + tL);
            value = value + 0.1;
        }
        // y values
        loops = (int) (maxBi - minBi) * 10;
        value = minBi;
        tickCount = minBi;
        for (int i = 0; i < loops; i++) {
            int pyt = (int) Utilities.scale(value, minB, maxB, panelHeight, 0);
            if (i % 10 == 0) {
                tL = 5;
                if (tickCount != 0) {
                    tickNumber = tickCount + "";
                    g2d.drawString(tickNumber, px0 + tL + bonus, pyt + fA / 2);
                }
                tickCount++;
            } else {
                tL = 2;
            }
            g2d.drawLine(px0 - tL, pyt, px0 + tL, pyt);
            value = value + 0.1;
        }
        g2d.dispose();
    }
    
    private void adjustComplexPlainMinMax() {
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();

        // lock point is lower left
        // maxA = minA + (zoom * panelWidth);
        // maxB = minB + (zoom * panelHeight);
        // lock point is upper right
        // minA = maxA - (zoom * panelWidth);
        // minB = maxB - (zoom * panelHeight);
        // lock point is upper right
        maxA = minA + (zoom * panelWidth);
        minB = maxB - (zoom * panelHeight);

        // testing
        // panelRatio should be almost equal to complexPlainRatio
        // double panelRatio = (double) panelWidth / (double) panelHeight;
        // double complexPlainRatio = (maxA - minA) / (maxB - minB);      
    }
    
    public void adjustImageIterations() {
        // increase maxImageIterations while zooming, empirical formula
        // 512 = basic minimum iterations, we use 100
        if (fmgApp.getAutoImageIterationsCheckBox().isSelected()) {
            maxImageIterations = (int) (512 * (1d + 0.5d * Math.log(1 / (maxA - minA))));
            if (maxImageIterations < 100) {
                maxImageIterations = 100;
            }
            fmgApp.getMaxImageIterationsSlider().setValue(maxImageIterations);
        }

        redrawImages();
    }    
    
    public void calculateFractal() {
        int width = this.getWidth();
        int height = this.getHeight();
        if ((width == 0) || (height == 0)) return;
        
        Runnable fractal = new Runnable() {
            @Override
            public void run() {
                try {
                    fmgApp.getRenderManager().render(fmgApp.getFractalPanel(), colorsArray,
                            maxImageIterations, width, height, minA, maxA, minB, maxB);
                } catch (Exception ex) {
                    String message = "ERROR while rendering fractal: " + ex.toString() + nl;
                    fmgApp.getTab1TextArea().append(message);
                }
            }
        };
        fmgApp.getFractalExecutorService().execute(fractal);
    }

    public void redrawImages() {
        adjustComplexPlainMinMax();
        if (fmgApp.getDrawCoordinatesCheckBox().isSelected()) {
            drawCoordinates();
        }
        if (orbitCalculatorOld != null) {
            drawOrbits(orbitCalculatorOld);
        }
        drawPath(true, -1, -1);       
        calculateFractal();
        repaint();
    }
    
    public void resetImages() {
        imageOrbits = null;
        imagePath = null;
        orbitCalculatorOld = null;
        outlineComplexArrayList = new ArrayList<>();
        imagePathIndex = 0;
        repaint();
    }
    
    public void resetPath() {
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();
        if ((panelWidth == 0) || (panelHeight == 0)) return;
        imagePath = new BufferedImage(panelWidth, panelHeight,
                BufferedImage.TYPE_INT_ARGB);
        if (fmgApp.getLockOutlineToggleButton().isSelected() == true) {
            drawPath(true, -1, -1);
        }
    }

    public void clearImagePath() {      
        Graphics2D g2d = imagePath.createGraphics();
        g2d.setBackground(new Color(0, 0, 0, 0));
        g2d.clearRect(0, 0, imagePath.getWidth(), imagePath.getHeight());
        g2d.dispose();
    }    
        
    // Getters and Setters:
    public double getZoom() {
        return zoom;
    }

    public void setZoom(double zoom) {
        this.zoom = zoom;
    }

    public double getMinA() {
        return minA;
    }

    public void setMinA(double minA) {
        this.minA = minA;
    }

    public double getMaxB() {
        return maxB;
    }

    public void setMaxB(double maxB) {    
        this.maxB = maxB;
    }

    public void setImageCoordinates(BufferedImage imageCoordinates) {
        this.imageCoordinates = imageCoordinates;
    }

    public void setImageFractal(BufferedImage imageFractal) {
        this.imageFractal = imageFractal;
    }

    public void setMaxImageIterations(int maxImageIterations) {
        this.maxImageIterations = maxImageIterations;
    }

    public int[] getColorsArray() {
        return colorsArray;
    }

    public void setColorsArray(int[] colorsArray) {
        this.colorsArray = colorsArray;
    }

    @Override
    public void paintComponent(Graphics g) {
        // it is used to draw a vanilla background
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;

        g2d.drawImage(imageFractal, 0, 0, this);
        g2d.drawImage(imageCoordinates, 0, 0, this);    
        g2d.drawImage(imageOrbits, 0, 0, this);
        g2d.drawImage(imagePath, 0, 0, this);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    // Custom variables
    private String nl = System.lineSeparator();
    private FmgApp fmgApp;
    int maxImageIterations = 100;
    // to center the A complex axis in image: zoom = (maxB - minB) / panelHeight
    // eg.: initial conditions, (1.25 - (-1.25)) / 312 = 0.008012821
    private double zoom = 0.009453352051159363; // initial value, how big the fractal is
    private double wheelScalingSensitivity = 0.1;
    private int pxMouseDragOld;
    private int pyMouseDragOld;
    private double minA = -2.449034800448149; // initial value, topLeft corner as lock point
    private double maxA; // will be calculated according to panel dimension
    private double minB; // will be calculated according to panel dimension
    private double maxB = 1.1843790692252911; // initial value, topLeft corner as lock point
    private BufferedImage imageOrbits;
    private BufferedImage imageFractal;
    private BufferedImage imagePath;
    private BufferedImage imageCoordinates;
    private final int PALETTELENGTH = ColorPanel.PALETTELENGTH;
    private int[] colorsArray = new int[PALETTELENGTH + 1];
    private OrbitCalculator orbitCalculatorOld;
    private ArrayList<double[]> outlineComplexArrayList = new ArrayList<>();
    private int imagePathIndex;
}
